// AUTOGENERATED

package client

import (
    "errors"
)

// Returns the current authorization state; this is an offline request. For informational purposes only. Use updateAuthorizationState instead to maintain the current authorization state
func (client *Client) GetAuthorizationState() (AuthorizationState, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getAuthorizationState",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    switch result.Type {
    case TypeAuthorizationStateWaitTdlibParameters:
        return UnmarshalAuthorizationStateWaitTdlibParameters(result.Data)

    case TypeAuthorizationStateWaitEncryptionKey:
        return UnmarshalAuthorizationStateWaitEncryptionKey(result.Data)

    case TypeAuthorizationStateWaitPhoneNumber:
        return UnmarshalAuthorizationStateWaitPhoneNumber(result.Data)

    case TypeAuthorizationStateWaitCode:
        return UnmarshalAuthorizationStateWaitCode(result.Data)

    case TypeAuthorizationStateWaitPassword:
        return UnmarshalAuthorizationStateWaitPassword(result.Data)

    case TypeAuthorizationStateReady:
        return UnmarshalAuthorizationStateReady(result.Data)

    case TypeAuthorizationStateLoggingOut:
        return UnmarshalAuthorizationStateLoggingOut(result.Data)

    case TypeAuthorizationStateClosing:
        return UnmarshalAuthorizationStateClosing(result.Data)

    case TypeAuthorizationStateClosed:
        return UnmarshalAuthorizationStateClosed(result.Data)

    default:
        return nil, errors.New("invalid type")
   }
}

// Sets the parameters for TDLib initialization. Works only when the current authorization state is authorizationStateWaitTdlibParameters
//
// @param parameters Parameters
func (client *Client) SetTdlibParameters(parameters *TdlibParameters) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setTdlibParameters",
        },
        Data: map[string]interface{}{
            "parameters": parameters,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Checks the database encryption key for correctness. Works only when the current authorization state is authorizationStateWaitEncryptionKey
//
// @param encryptionKey Encryption key to check or set up
func (client *Client) CheckDatabaseEncryptionKey(encryptionKey []byte) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "checkDatabaseEncryptionKey",
        },
        Data: map[string]interface{}{
            "encryption_key": encryptionKey,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Sets the phone number of the user and sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitPhoneNumber
//
// @param phoneNumber The phone number of the user, in international format
// @param allowFlashCall Pass true if the authentication code may be sent via flash call to the specified phone number
// @param isCurrentPhoneNumber Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false
func (client *Client) SetAuthenticationPhoneNumber(phoneNumber string, allowFlashCall bool, isCurrentPhoneNumber bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setAuthenticationPhoneNumber",
        },
        Data: map[string]interface{}{
            "phone_number": phoneNumber,
            "allow_flash_call": allowFlashCall,
            "is_current_phone_number": isCurrentPhoneNumber,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Re-sends an authentication code to the user. Works only when the current authorization state is authorizationStateWaitCode and the next_code_type of the result is not null
func (client *Client) ResendAuthenticationCode() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "resendAuthenticationCode",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Checks the authentication code. Works only when the current authorization state is authorizationStateWaitCode
//
// @param code The verification code received via SMS, Telegram message, phone call, or flash call
// @param firstName If the user is not yet registered, the first name of the user; 1-255 characters
// @param lastName If the user is not yet registered; the last name of the user; optional; 0-255 characters
func (client *Client) CheckAuthenticationCode(code string, firstName string, lastName string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "checkAuthenticationCode",
        },
        Data: map[string]interface{}{
            "code": code,
            "first_name": firstName,
            "last_name": lastName,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Checks the authentication password for correctness. Works only when the current authorization state is authorizationStateWaitPassword
//
// @param password The password to check
func (client *Client) CheckAuthenticationPassword(password string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "checkAuthenticationPassword",
        },
        Data: map[string]interface{}{
            "password": password,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Requests to send a password recovery code to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
func (client *Client) RequestAuthenticationPasswordRecovery() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "requestAuthenticationPasswordRecovery",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Recovers the password with a password recovery code sent to an email address that was previously set up. Works only when the current authorization state is authorizationStateWaitPassword
//
// @param recoveryCode Recovery code to check
func (client *Client) RecoverAuthenticationPassword(recoveryCode string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "recoverAuthenticationPassword",
        },
        Data: map[string]interface{}{
            "recovery_code": recoveryCode,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Checks the authentication token of a bot; to log in as a bot. Works only when the current authorization state is authorizationStateWaitPhoneNumber. Can be used instead of setAuthenticationPhoneNumber and checkAuthenticationCode to log in
//
// @param token The bot token
func (client *Client) CheckAuthenticationBotToken(token string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "checkAuthenticationBotToken",
        },
        Data: map[string]interface{}{
            "token": token,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Closes the TDLib instance after a proper logout. Requires an available network connection. All local data will be destroyed. After the logout completes, updateAuthorizationState with authorizationStateClosed will be sent
func (client *Client) LogOut() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "logOut",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Closes the TDLib instance. All databases will be flushed to disk and properly closed. After the close completes, updateAuthorizationState with authorizationStateClosed will be sent
func (client *Client) Close() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "close",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Closes the TDLib instance, destroying all local data without a proper logout. The current user session will remain in the list of all active sessions. All local data will be destroyed. After the destruction completes updateAuthorizationState with authorizationStateClosed will be sent
func (client *Client) Destroy() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "destroy",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the database encryption key. Usually the encryption key is never changed and is stored in some OS keychain
//
// @param newEncryptionKey New encryption key
func (client *Client) SetDatabaseEncryptionKey(newEncryptionKey []byte) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setDatabaseEncryptionKey",
        },
        Data: map[string]interface{}{
            "new_encryption_key": newEncryptionKey,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns the current state of 2-step verification
func (client *Client) GetPasswordState() (*PasswordState, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getPasswordState",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalPasswordState(result.Data)
}

// Changes the password for the user. If a new recovery email address is specified, then the error EMAIL_UNCONFIRMED is returned and the password change will not be applied until the new recovery email address has been confirmed. The application should periodically call getPasswordState to check whether the new email address has been confirmed
//
// @param oldPassword Previous password of the user
// @param newPassword New password of the user; may be empty to remove the password
// @param newHint New password hint; may be empty
// @param setRecoveryEmailAddress Pass true if the recovery email address should be changed
// @param newRecoveryEmailAddress New recovery email address; may be empty
func (client *Client) SetPassword(oldPassword string, newPassword string, newHint string, setRecoveryEmailAddress bool, newRecoveryEmailAddress string) (*PasswordState, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setPassword",
        },
        Data: map[string]interface{}{
            "old_password": oldPassword,
            "new_password": newPassword,
            "new_hint": newHint,
            "set_recovery_email_address": setRecoveryEmailAddress,
            "new_recovery_email_address": newRecoveryEmailAddress,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalPasswordState(result.Data)
}

// Returns a recovery email address that was previously set up. This method can be used to verify a password provided by the user
//
// @param password The password for the current user
func (client *Client) GetRecoveryEmailAddress(password string) (*RecoveryEmailAddress, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getRecoveryEmailAddress",
        },
        Data: map[string]interface{}{
            "password": password,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalRecoveryEmailAddress(result.Data)
}

// Changes the recovery email address of the user. If a new recovery email address is specified, then the error EMAIL_UNCONFIRMED is returned and the email address will not be changed until the new email has been confirmed. The application should periodically call getPasswordState to check whether the email address has been confirmed. If new_recovery_email_address is the same as the email address that is currently set up, this call succeeds immediately and aborts all other requests waiting for an email confirmation
//
// @param password Password of the current user
// @param newRecoveryEmailAddress New recovery email address
func (client *Client) SetRecoveryEmailAddress(password string, newRecoveryEmailAddress string) (*PasswordState, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setRecoveryEmailAddress",
        },
        Data: map[string]interface{}{
            "password": password,
            "new_recovery_email_address": newRecoveryEmailAddress,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalPasswordState(result.Data)
}

// Requests to send a password recovery code to an email address that was previously set up
func (client *Client) RequestPasswordRecovery() (*PasswordRecoveryInfo, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "requestPasswordRecovery",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalPasswordRecoveryInfo(result.Data)
}

// Recovers the password using a recovery code sent to an email address that was previously set up
//
// @param recoveryCode Recovery code to check
func (client *Client) RecoverPassword(recoveryCode string) (*PasswordState, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "recoverPassword",
        },
        Data: map[string]interface{}{
            "recovery_code": recoveryCode,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalPasswordState(result.Data)
}

// Creates a new temporary password for processing payments
//
// @param password Persistent user password
// @param validFor Time during which the temporary password will be valid, in seconds; should be between 60 and 86400
func (client *Client) CreateTemporaryPassword(password string, validFor int32) (*TemporaryPasswordState, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createTemporaryPassword",
        },
        Data: map[string]interface{}{
            "password": password,
            "valid_for": validFor,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTemporaryPasswordState(result.Data)
}

// Returns information about the current temporary password
func (client *Client) GetTemporaryPasswordState() (*TemporaryPasswordState, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getTemporaryPasswordState",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTemporaryPasswordState(result.Data)
}

// Handles a DC_UPDATE push service notification. Can be called before authorization
//
// @param dc Value of the "dc" parameter of the notification
// @param addr Value of the "addr" parameter of the notification
func (client *Client) ProcessDcUpdate(dc string, addr string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "processDcUpdate",
        },
        Data: map[string]interface{}{
            "dc": dc,
            "addr": addr,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns the current user
func (client *Client) GetMe() (*User, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getMe",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUser(result.Data)
}

// Returns information about a user by their identifier. This is an offline request if the current user is not a bot
//
// @param userId User identifier
func (client *Client) GetUser(userId int32) (*User, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getUser",
        },
        Data: map[string]interface{}{
            "user_id": userId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUser(result.Data)
}

// Returns full information about a user by their identifier
//
// @param userId User identifier
func (client *Client) GetUserFullInfo(userId int32) (*UserFullInfo, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getUserFullInfo",
        },
        Data: map[string]interface{}{
            "user_id": userId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUserFullInfo(result.Data)
}

// Returns information about a basic group by its identifier. This is an offline request if the current user is not a bot
//
// @param basicGroupId Basic group identifier
func (client *Client) GetBasicGroup(basicGroupId int32) (*BasicGroup, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getBasicGroup",
        },
        Data: map[string]interface{}{
            "basic_group_id": basicGroupId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalBasicGroup(result.Data)
}

// Returns full information about a basic group by its identifier
//
// @param basicGroupId Basic group identifier
func (client *Client) GetBasicGroupFullInfo(basicGroupId int32) (*BasicGroupFullInfo, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getBasicGroupFullInfo",
        },
        Data: map[string]interface{}{
            "basic_group_id": basicGroupId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalBasicGroupFullInfo(result.Data)
}

// Returns information about a supergroup or channel by its identifier. This is an offline request if the current user is not a bot
//
// @param supergroupId Supergroup or channel identifier
func (client *Client) GetSupergroup(supergroupId int32) (*Supergroup, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getSupergroup",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalSupergroup(result.Data)
}

// Returns full information about a supergroup or channel by its identifier, cached for up to 1 minute
//
// @param supergroupId Supergroup or channel identifier
func (client *Client) GetSupergroupFullInfo(supergroupId int32) (*SupergroupFullInfo, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getSupergroupFullInfo",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalSupergroupFullInfo(result.Data)
}

// Returns information about a secret chat by its identifier. This is an offline request
//
// @param secretChatId Secret chat identifier
func (client *Client) GetSecretChat(secretChatId int32) (*SecretChat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getSecretChat",
        },
        Data: map[string]interface{}{
            "secret_chat_id": secretChatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalSecretChat(result.Data)
}

// Returns information about a chat by its identifier, this is an offline request if the current user is not a bot
//
// @param chatId Chat identifier
func (client *Client) GetChat(chatId int64) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getChat",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Returns information about a message
//
// @param chatId Identifier of the chat the message belongs to
// @param messageId Identifier of the message to get
func (client *Client) GetMessage(chatId int64, messageId int64) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getMessage",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Returns information about a message that is replied by given message
//
// @param chatId Identifier of the chat the message belongs to
// @param messageId Identifier of the message reply to which get
func (client *Client) GetRepliedMessage(chatId int64, messageId int64) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getRepliedMessage",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Returns information about a pinned chat message
//
// @param chatId Identifier of the chat the message belongs to
func (client *Client) GetChatPinnedMessage(chatId int64) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getChatPinnedMessage",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Returns information about messages. If a message is not found, returns null on the corresponding position of the result
//
// @param chatId Identifier of the chat the messages belong to
// @param messageIds Identifiers of the messages to get
func (client *Client) GetMessages(chatId int64, messageIds []int64) (*Messages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getMessages",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_ids": messageIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessages(result.Data)
}

// Returns information about a file; this is an offline request
//
// @param fileId Identifier of the file to get
func (client *Client) GetFile(fileId int32) (*File, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getFile",
        },
        Data: map[string]interface{}{
            "file_id": fileId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalFile(result.Data)
}

// Returns information about a file by its remote ID; this is an offline request. Can be used to register a URL as a file for further uploading, or sending as a message
//
// @param remoteFileId Remote identifier of the file to get
// @param fileType File type, if known
func (client *Client) GetRemoteFile(remoteFileId string, fileType FileType) (*File, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getRemoteFile",
        },
        Data: map[string]interface{}{
            "remote_file_id": remoteFileId,
            "file_type": fileType,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalFile(result.Data)
}

// Returns an ordered list of chats. Chats are sorted by the pair (order, chat_id) in decreasing order. (For example, to get a list of chats from the beginning, the offset_order should be equal to 2^63 - 1). For optimal performance the number of returned chats is chosen by the library.
//
// @param offsetOrder Chat order to return chats from
// @param offsetChatId Chat identifier to return chats from
// @param limit The maximum number of chats to be returned. It is possible that fewer chats than the limit are returned even if the end of the list is not reached
func (client *Client) GetChats(offsetOrder JsonInt64, offsetChatId int64, limit int32) (*Chats, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getChats",
        },
        Data: map[string]interface{}{
            "offset_order": offsetOrder,
            "offset_chat_id": offsetChatId,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChats(result.Data)
}

// Searches a public chat by its username. Currently only private chats, supergroups and channels can be public. Returns the chat if found; otherwise an error is returned
//
// @param username Username to be resolved
func (client *Client) SearchPublicChat(username string) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchPublicChat",
        },
        Data: map[string]interface{}{
            "username": username,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Searches public chats by looking for specified query in their username and title. Currently only private chats, supergroups and channels can be public. Returns a meaningful number of results. Returns nothing if the length of the searched username prefix is less than 5. Excludes private chats with contacts and chats from the chat list from the results
//
// @param query Query to search for
func (client *Client) SearchPublicChats(query string) (*Chats, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchPublicChats",
        },
        Data: map[string]interface{}{
            "query": query,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChats(result.Data)
}

// Searches for the specified query in the title and username of already known chats, this is an offline request. Returns chats in the order seen in the chat list
//
// @param query Query to search for. If the query is empty, returns up to 20 recently found chats
// @param limit Maximum number of chats to be returned
func (client *Client) SearchChats(query string, limit int32) (*Chats, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchChats",
        },
        Data: map[string]interface{}{
            "query": query,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChats(result.Data)
}

// Searches for the specified query in the title and username of already known chats via request to the server. Returns chats in the order seen in the chat list
//
// @param query Query to search for
// @param limit Maximum number of chats to be returned
func (client *Client) SearchChatsOnServer(query string, limit int32) (*Chats, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchChatsOnServer",
        },
        Data: map[string]interface{}{
            "query": query,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChats(result.Data)
}

// Returns a list of frequently used chats. Supported only if the chat info database is enabled
//
// @param category Category of chats to be returned
// @param limit Maximum number of chats to be returned; up to 30
func (client *Client) GetTopChats(category TopChatCategory, limit int32) (*Chats, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getTopChats",
        },
        Data: map[string]interface{}{
            "category": category,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChats(result.Data)
}

// Removes a chat from the list of frequently used chats. Supported only if the chat info database is enabled
//
// @param category Category of frequently used chats
// @param chatId Chat identifier
func (client *Client) RemoveTopChat(category TopChatCategory, chatId int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "removeTopChat",
        },
        Data: map[string]interface{}{
            "category": category,
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Adds a chat to the list of recently found chats. The chat is added to the beginning of the list. If the chat is already in the list, it will be removed from the list first
//
// @param chatId Identifier of the chat to add
func (client *Client) AddRecentlyFoundChat(chatId int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "addRecentlyFoundChat",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Removes a chat from the list of recently found chats
//
// @param chatId Identifier of the chat to be removed
func (client *Client) RemoveRecentlyFoundChat(chatId int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "removeRecentlyFoundChat",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Clears the list of recently found chats
func (client *Client) ClearRecentlyFoundChats() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "clearRecentlyFoundChats",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Checks whether a username can be set for a chat
//
// @param chatId Chat identifier; should be identifier of a supergroup chat, or a channel chat, or a private chat with self, or zero if chat is being created
// @param username Username to be checked
func (client *Client) CheckChatUsername(chatId JsonInt64, username string) (CheckChatUsernameResult, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "checkChatUsername",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "username": username,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    switch result.Type {
    case TypeCheckChatUsernameResultOk:
        return UnmarshalCheckChatUsernameResultOk(result.Data)

    case TypeCheckChatUsernameResultUsernameInvalid:
        return UnmarshalCheckChatUsernameResultUsernameInvalid(result.Data)

    case TypeCheckChatUsernameResultUsernameOccupied:
        return UnmarshalCheckChatUsernameResultUsernameOccupied(result.Data)

    case TypeCheckChatUsernameResultPublicChatsTooMuch:
        return UnmarshalCheckChatUsernameResultPublicChatsTooMuch(result.Data)

    case TypeCheckChatUsernameResultPublicGroupsUnavailable:
        return UnmarshalCheckChatUsernameResultPublicGroupsUnavailable(result.Data)

    default:
        return nil, errors.New("invalid type")
   }
}

// Returns a list of public chats created by the user
func (client *Client) GetCreatedPublicChats() (*Chats, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getCreatedPublicChats",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChats(result.Data)
}

// Returns a list of common chats with a given user. Chats are sorted by their type and creation date
//
// @param userId User identifier
// @param offsetChatId Chat identifier starting from which to return chats; use 0 for the first request
// @param limit Maximum number of chats to be returned; up to 100
func (client *Client) GetGroupsInCommon(userId int32, offsetChatId int64, limit int32) (*Chats, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getGroupsInCommon",
        },
        Data: map[string]interface{}{
            "user_id": userId,
            "offset_chat_id": offsetChatId,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChats(result.Data)
}

// Returns messages in a chat. The messages are returned in a reverse chronological order (i.e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library. This is an offline request if only_local is true
//
// @param chatId Chat identifier
// @param fromMessageId Identifier of the message starting from which history must be fetched; use 0 to get results from the beginning (i.e., from oldest to newest)
// @param offset Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages
// @param limit The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached
// @param onlyLocal If true, returns only messages that are available locally without sending network requests
func (client *Client) GetChatHistory(chatId int64, fromMessageId int64, offset int32, limit int32, onlyLocal bool) (*Messages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getChatHistory",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "from_message_id": fromMessageId,
            "offset": offset,
            "limit": limit,
            "only_local": onlyLocal,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessages(result.Data)
}

// Deletes all messages in the chat only for the user. Cannot be used in channels and public supergroups
//
// @param chatId Chat identifier
// @param removeFromChatList Pass true if the chat should be removed from the chats list
func (client *Client) DeleteChatHistory(chatId int64, removeFromChatList bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteChatHistory",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "remove_from_chat_list": removeFromChatList,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Searches for messages with given words in the chat. Returns the results in reverse chronological order, i.e. in order of decreasing message_id. Cannot be used in secret chats with a non-empty query (searchSecretMessages should be used instead), or without an enabled message database. For optimal performance the number of returned messages is chosen by the library
//
// @param chatId Identifier of the chat in which to search messages
// @param query Query to search for
// @param senderUserId If not 0, only messages sent by the specified user will be returned. Not supported in secret chats
// @param fromMessageId Identifier of the message starting from which history must be fetched; use 0 to get results from the beginning
// @param offset Specify 0 to get results from exactly the from_message_id or a negative offset to get the specified message and some newer messages
// @param limit The maximum number of messages to be returned; must be positive and can't be greater than 100. If the offset is negative, the limit must be greater than -offset. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached
// @param filter Filter for message content in the search results
func (client *Client) SearchChatMessages(chatId int64, query string, senderUserId int32, fromMessageId int64, offset int32, limit int32, filter SearchMessagesFilter) (*Messages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchChatMessages",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "query": query,
            "sender_user_id": senderUserId,
            "from_message_id": fromMessageId,
            "offset": offset,
            "limit": limit,
            "filter": filter,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessages(result.Data)
}

// Searches for messages in all chats except secret chats. Returns the results in reverse chronological order (i.e., in order of decreasing (date, chat_id, message_id)). For optimal performance the number of returned messages is chosen by the library
//
// @param query Query to search for
// @param offsetDate The date of the message starting from which the results should be fetched. Use 0 or any date in the future to get results from the beginning
// @param offsetChatId The chat identifier of the last found message, or 0 for the first request
// @param offsetMessageId The message identifier of the last found message, or 0 for the first request
// @param limit The maximum number of messages to be returned, up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached
func (client *Client) SearchMessages(query string, offsetDate int32, offsetChatId int64, offsetMessageId int64, limit int32) (*Messages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchMessages",
        },
        Data: map[string]interface{}{
            "query": query,
            "offset_date": offsetDate,
            "offset_chat_id": offsetChatId,
            "offset_message_id": offsetMessageId,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessages(result.Data)
}

// Searches for messages in secret chats. Returns the results in reverse chronological order. For optimal performance the number of returned messages is chosen by the library
//
// @param chatId Identifier of the chat in which to search. Specify 0 to search in all secret chats
// @param query Query to search for. If empty, searchChatMessages should be used instead
// @param fromSearchId The identifier from the result of a previous request, use 0 to get results from the beginning
// @param limit Maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached
// @param filter A filter for the content of messages in the search results
func (client *Client) SearchSecretMessages(chatId int64, query string, fromSearchId JsonInt64, limit int32, filter SearchMessagesFilter) (*FoundMessages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchSecretMessages",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "query": query,
            "from_search_id": fromSearchId,
            "limit": limit,
            "filter": filter,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalFoundMessages(result.Data)
}

// Searches for call messages. Returns the results in reverse chronological order (i. e., in order of decreasing message_id). For optimal performance the number of returned messages is chosen by the library
//
// @param fromMessageId Identifier of the message from which to search; use 0 to get results from the beginning
// @param limit The maximum number of messages to be returned; up to 100. Fewer messages may be returned than specified by the limit, even if the end of the message history has not been reached
// @param onlyMissed If true, returns only messages with missed calls
func (client *Client) SearchCallMessages(fromMessageId int64, limit int32, onlyMissed bool) (*Messages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchCallMessages",
        },
        Data: map[string]interface{}{
            "from_message_id": fromMessageId,
            "limit": limit,
            "only_missed": onlyMissed,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessages(result.Data)
}

// Returns information about the recent locations of chat members that were sent to the chat. Returns up to 1 location message per user
//
// @param chatId Chat identifier
// @param limit Maximum number of messages to be returned
func (client *Client) SearchChatRecentLocationMessages(chatId int64, limit int32) (*Messages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchChatRecentLocationMessages",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessages(result.Data)
}

// Returns all active live locations that should be updated by the client. The list is persistent across application restarts only if the message database is used
func (client *Client) GetActiveLiveLocationMessages() (*Messages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getActiveLiveLocationMessages",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessages(result.Data)
}

// Returns the last message sent in a chat no later than the specified date
//
// @param chatId Chat identifier
// @param date Point in time (Unix timestamp) relative to which to search for messages
func (client *Client) GetChatMessageByDate(chatId int64, date int32) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getChatMessageByDate",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "date": date,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Returns a public HTTPS link to a message. Available only for messages in public supergroups and channels
//
// @param chatId Identifier of the chat to which the message belongs
// @param messageId Identifier of the message
// @param forAlbum Pass true if a link for a whole media album should be returned
func (client *Client) GetPublicMessageLink(chatId int64, messageId int64, forAlbum bool) (*PublicMessageLink, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getPublicMessageLink",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "for_album": forAlbum,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalPublicMessageLink(result.Data)
}

// Sends a message. Returns the sent message
//
// @param chatId Target chat
// @param replyToMessageId Identifier of the message to reply to or 0
// @param disableNotification Pass true to disable notification for the message. Not supported in secret chats
// @param fromBackground Pass true if the message is sent from the background
// @param replyMarkup Markup for replying to the message; for bots only
// @param inputMessageContent The content of the message to be sent
func (client *Client) SendMessage(chatId int64, replyToMessageId int64, disableNotification bool, fromBackground bool, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendMessage",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "reply_to_message_id": replyToMessageId,
            "disable_notification": disableNotification,
            "from_background": fromBackground,
            "reply_markup": replyMarkup,
            "input_message_content": inputMessageContent,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Sends messages grouped together into an album. Currently only photo and video messages can be grouped into an album. Returns sent messages
//
// @param chatId Target chat
// @param replyToMessageId Identifier of a message to reply to or 0
// @param disableNotification Pass true to disable notification for the messages. Not supported in secret chats
// @param fromBackground Pass true if the messages are sent from the background
// @param inputMessageContents Contents of messages to be sent
func (client *Client) SendMessageAlbum(chatId int64, replyToMessageId int64, disableNotification bool, fromBackground bool, inputMessageContents []InputMessageContent) (*Messages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendMessageAlbum",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "reply_to_message_id": replyToMessageId,
            "disable_notification": disableNotification,
            "from_background": fromBackground,
            "input_message_contents": inputMessageContents,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessages(result.Data)
}

// Invites a bot to a chat (if it is not yet a member) and sends it the /start command. Bots can't be invited to a private chat other than the chat with the bot. Bots can't be invited to channels (although they can be added as admins) and secret chats. Returns the sent message
//
// @param botUserId Identifier of the bot
// @param chatId Identifier of the target chat
// @param parameter A hidden parameter sent to the bot for deep linking purposes (https://api.telegram.org/bots#deep-linking)
func (client *Client) SendBotStartMessage(botUserId int32, chatId int64, parameter string) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendBotStartMessage",
        },
        Data: map[string]interface{}{
            "bot_user_id": botUserId,
            "chat_id": chatId,
            "parameter": parameter,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Sends the result of an inline query as a message. Returns the sent message. Always clears a chat draft message
//
// @param chatId Target chat
// @param replyToMessageId Identifier of a message to reply to or 0
// @param disableNotification Pass true to disable notification for the message. Not supported in secret chats
// @param fromBackground Pass true if the message is sent from background
// @param queryId Identifier of the inline query
// @param resultId Identifier of the inline result
func (client *Client) SendInlineQueryResultMessage(chatId int64, replyToMessageId int64, disableNotification bool, fromBackground bool, queryId JsonInt64, resultId string) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendInlineQueryResultMessage",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "reply_to_message_id": replyToMessageId,
            "disable_notification": disableNotification,
            "from_background": fromBackground,
            "query_id": queryId,
            "result_id": resultId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Forwards previously sent messages. Returns the forwarded messages in the same order as the message identifiers passed in message_ids. If a message can't be forwarded, null will be returned instead of the message
//
// @param chatId Identifier of the chat to which to forward messages
// @param fromChatId Identifier of the chat from which to forward messages
// @param messageIds Identifiers of the messages to forward
// @param disableNotification Pass true to disable notification for the message, doesn't work if messages are forwarded to a secret chat
// @param fromBackground Pass true if the message is sent from the background
// @param asAlbum True, if the messages should be grouped into an album after forwarding. For this to work, no more than 10 messages may be forwarded, and all of them must be photo or video messages
func (client *Client) ForwardMessages(chatId int64, fromChatId int64, messageIds []int64, disableNotification bool, fromBackground bool, asAlbum bool) (*Messages, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "forwardMessages",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "from_chat_id": fromChatId,
            "message_ids": messageIds,
            "disable_notification": disableNotification,
            "from_background": fromBackground,
            "as_album": asAlbum,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessages(result.Data)
}

// Changes the current TTL setting (sets a new self-destruct timer) in a secret chat and sends the corresponding message
//
// @param chatId Chat identifier
// @param ttl New TTL value, in seconds
func (client *Client) SendChatSetTtlMessage(chatId int64, ttl int32) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendChatSetTtlMessage",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "ttl": ttl,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Sends a notification about a screenshot taken in a chat. Supported only in private and secret chats
//
// @param chatId Chat identifier
func (client *Client) SendChatScreenshotTakenNotification(chatId int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendChatScreenshotTakenNotification",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Deletes messages
//
// @param chatId Chat identifier
// @param messageIds Identifiers of the messages to be deleted
// @param revoke Pass true to try to delete outgoing messages for all chat members (may fail if messages are too old). Always true for supergroups, channels and secret chats
func (client *Client) DeleteMessages(chatId int64, messageIds []int64, revoke bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteMessages",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_ids": messageIds,
            "revoke": revoke,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Deletes all messages sent by the specified user to a chat. Supported only in supergroups; requires can_delete_messages administrator privileges
//
// @param chatId Chat identifier
// @param userId User identifier
func (client *Client) DeleteChatMessagesFromUser(chatId int64, userId int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteChatMessagesFromUser",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "user_id": userId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Edits the text of a message (or a text of a game message). Non-bot users can edit messages for a limited period of time. Returns the edited message after the edit is completed on the server side
//
// @param chatId The chat the message belongs to
// @param messageId Identifier of the message
// @param replyMarkup The new message reply markup; for bots only
// @param inputMessageContent New text content of the message. Should be of type InputMessageText
func (client *Client) EditMessageText(chatId int64, messageId int64, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "editMessageText",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "reply_markup": replyMarkup,
            "input_message_content": inputMessageContent,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Edits the message content of a live location. Messages can be edited for a limited period of time specified in the live location. Returns the edited message after the edit is completed server-side
//
// @param chatId The chat the message belongs to
// @param messageId Identifier of the message
// @param replyMarkup Tew message reply markup; for bots only
// @param location New location content of the message; may be null. Pass null to stop sharing the live location
func (client *Client) EditMessageLiveLocation(chatId int64, messageId int64, replyMarkup ReplyMarkup, location *Location) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "editMessageLiveLocation",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "reply_markup": replyMarkup,
            "location": location,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Edits the message content caption. Non-bots can edit messages for a limited period of time. Returns the edited message after the edit is completed server-side
//
// @param chatId The chat the message belongs to
// @param messageId Identifier of the message
// @param replyMarkup The new message reply markup; for bots only
// @param caption New message content caption; 0-200 characters
func (client *Client) EditMessageCaption(chatId int64, messageId int64, replyMarkup ReplyMarkup, caption *FormattedText) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "editMessageCaption",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "reply_markup": replyMarkup,
            "caption": caption,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Edits the message reply markup; for bots only. Returns the edited message after the edit is completed server-side
//
// @param chatId The chat the message belongs to
// @param messageId Identifier of the message
// @param replyMarkup New message reply markup
func (client *Client) EditMessageReplyMarkup(chatId int64, messageId int64, replyMarkup ReplyMarkup) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "editMessageReplyMarkup",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "reply_markup": replyMarkup,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Edits the text of an inline text or game message sent via a bot; for bots only
//
// @param inlineMessageId Inline message identifier
// @param replyMarkup New message reply markup
// @param inputMessageContent New text content of the message. Should be of type InputMessageText
func (client *Client) EditInlineMessageText(inlineMessageId string, replyMarkup ReplyMarkup, inputMessageContent InputMessageContent) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "editInlineMessageText",
        },
        Data: map[string]interface{}{
            "inline_message_id": inlineMessageId,
            "reply_markup": replyMarkup,
            "input_message_content": inputMessageContent,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Edits the content of a live location in an inline message sent via a bot; for bots only
//
// @param inlineMessageId Inline message identifier
// @param replyMarkup New message reply markup
// @param location New location content of the message; may be null. Pass null to stop sharing the live location
func (client *Client) EditInlineMessageLiveLocation(inlineMessageId string, replyMarkup ReplyMarkup, location *Location) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "editInlineMessageLiveLocation",
        },
        Data: map[string]interface{}{
            "inline_message_id": inlineMessageId,
            "reply_markup": replyMarkup,
            "location": location,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Edits the caption of an inline message sent via a bot; for bots only
//
// @param inlineMessageId Inline message identifier
// @param replyMarkup New message reply markup
// @param caption New message content caption; 0-200 characters
func (client *Client) EditInlineMessageCaption(inlineMessageId string, replyMarkup ReplyMarkup, caption *FormattedText) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "editInlineMessageCaption",
        },
        Data: map[string]interface{}{
            "inline_message_id": inlineMessageId,
            "reply_markup": replyMarkup,
            "caption": caption,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Edits the reply markup of an inline message sent via a bot; for bots only
//
// @param inlineMessageId Inline message identifier
// @param replyMarkup New message reply markup
func (client *Client) EditInlineMessageReplyMarkup(inlineMessageId string, replyMarkup ReplyMarkup) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "editInlineMessageReplyMarkup",
        },
        Data: map[string]interface{}{
            "inline_message_id": inlineMessageId,
            "reply_markup": replyMarkup,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns all entities (mentions, hashtags, cashtags, bot commands, URLs, and email addresses) contained in the text. This is an offline method. Can be called before authorization. Can be called synchronously
//
// @param text The text in which to look for entites
func (client *Client) GetTextEntities(text string) (*TextEntities, error) {
    result, err := client.jsonClient.Execute(Request{
        meta: meta{
            Type: "getTextEntities",
        },
        Data: map[string]interface{}{
            "text": text,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTextEntities(result.Data)
}

// Parses Bold, Italic, Code, Pre, PreCode and TextUrl entities contained in the text. This is an offline method. Can be called before authorization. Can be called synchronously
//
// @param text The text which should be parsed
// @param parseMode Text parse mode
func (client *Client) ParseTextEntities(text string, parseMode TextParseMode) (*FormattedText, error) {
    result, err := client.jsonClient.Execute(Request{
        meta: meta{
            Type: "parseTextEntities",
        },
        Data: map[string]interface{}{
            "text": text,
            "parse_mode": parseMode,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalFormattedText(result.Data)
}

// Returns the MIME type of a file, guessed by its extension. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously
//
// @param fileName The name of the file or path to the file
func (client *Client) GetFileMimeType(fileName string) (*Text, error) {
    result, err := client.jsonClient.Execute(Request{
        meta: meta{
            Type: "getFileMimeType",
        },
        Data: map[string]interface{}{
            "file_name": fileName,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalText(result.Data)
}

// Returns the extension of a file, guessed by its MIME type. Returns an empty string on failure. This is an offline method. Can be called before authorization. Can be called synchronously
//
// @param mimeType The MIME type of the file
func (client *Client) GetFileExtension(mimeType string) (*Text, error) {
    result, err := client.jsonClient.Execute(Request{
        meta: meta{
            Type: "getFileExtension",
        },
        Data: map[string]interface{}{
            "mime_type": mimeType,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalText(result.Data)
}

// Sends an inline query to a bot and returns its results. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
//
// @param botUserId The identifier of the target bot
// @param chatId Identifier of the chat, where the query was sent
// @param userLocation Location of the user, only if needed
// @param query Text of the query
// @param offset Offset of the first entry to return
func (client *Client) GetInlineQueryResults(botUserId int32, chatId int64, userLocation *Location, query string, offset string) (*InlineQueryResults, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getInlineQueryResults",
        },
        Data: map[string]interface{}{
            "bot_user_id": botUserId,
            "chat_id": chatId,
            "user_location": userLocation,
            "query": query,
            "offset": offset,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalInlineQueryResults(result.Data)
}

// Sets the result of an inline query; for bots only
//
// @param inlineQueryId Identifier of the inline query
// @param isPersonal True, if the result of the query can be cached for the specified user
// @param results The results of the query
// @param cacheTime Allowed time to cache the results of the query, in seconds
// @param nextOffset Offset for the next inline query; pass an empty string if there are no more results
// @param switchPmText If non-empty, this text should be shown on the button that opens a private chat with the bot and sends a start message to the bot with the parameter switch_pm_parameter
// @param switchPmParameter The parameter for the bot start message
func (client *Client) AnswerInlineQuery(inlineQueryId JsonInt64, isPersonal bool, results []InputInlineQueryResult, cacheTime int32, nextOffset string, switchPmText string, switchPmParameter string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "answerInlineQuery",
        },
        Data: map[string]interface{}{
            "inline_query_id": inlineQueryId,
            "is_personal": isPersonal,
            "results": results,
            "cache_time": cacheTime,
            "next_offset": nextOffset,
            "switch_pm_text": switchPmText,
            "switch_pm_parameter": switchPmParameter,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Sends a callback query to a bot and returns an answer. Returns an error with code 502 if the bot fails to answer the query before the query timeout expires
//
// @param chatId Identifier of the chat with the message
// @param messageId Identifier of the message from which the query originated
// @param payload Query payload
func (client *Client) GetCallbackQueryAnswer(chatId int64, messageId int64, payload CallbackQueryPayload) (*CallbackQueryAnswer, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getCallbackQueryAnswer",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "payload": payload,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalCallbackQueryAnswer(result.Data)
}

// Sets the result of a callback query; for bots only
//
// @param callbackQueryId Identifier of the callback query
// @param text Text of the answer
// @param showAlert If true, an alert should be shown to the user instead of a toast notification
// @param url URL to be opened
// @param cacheTime Time during which the result of the query can be cached, in seconds
func (client *Client) AnswerCallbackQuery(callbackQueryId JsonInt64, text string, showAlert bool, url string, cacheTime int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "answerCallbackQuery",
        },
        Data: map[string]interface{}{
            "callback_query_id": callbackQueryId,
            "text": text,
            "show_alert": showAlert,
            "url": url,
            "cache_time": cacheTime,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Sets the result of a shipping query; for bots only
//
// @param shippingQueryId Identifier of the shipping query
// @param shippingOptions Available shipping options
// @param errorMessage An error message, empty on success
func (client *Client) AnswerShippingQuery(shippingQueryId JsonInt64, shippingOptions []*ShippingOption, errorMessage string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "answerShippingQuery",
        },
        Data: map[string]interface{}{
            "shipping_query_id": shippingQueryId,
            "shipping_options": shippingOptions,
            "error_message": errorMessage,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Sets the result of a pre-checkout query; for bots only
//
// @param preCheckoutQueryId Identifier of the pre-checkout query
// @param errorMessage An error message, empty on success
func (client *Client) AnswerPreCheckoutQuery(preCheckoutQueryId JsonInt64, errorMessage string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "answerPreCheckoutQuery",
        },
        Data: map[string]interface{}{
            "pre_checkout_query_id": preCheckoutQueryId,
            "error_message": errorMessage,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Updates the game score of the specified user in the game; for bots only
//
// @param chatId The chat to which the message with the game
// @param messageId Identifier of the message
// @param editMessage True, if the message should be edited
// @param userId User identifier
// @param score The new score
// @param force Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
func (client *Client) SetGameScore(chatId int64, messageId int64, editMessage bool, userId int32, score int32, force bool) (*Message, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setGameScore",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "edit_message": editMessage,
            "user_id": userId,
            "score": score,
            "force": force,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalMessage(result.Data)
}

// Updates the game score of the specified user in a game; for bots only
//
// @param inlineMessageId Inline message identifier
// @param editMessage True, if the message should be edited
// @param userId User identifier
// @param score The new score
// @param force Pass true to update the score even if it decreases. If the score is 0, the user will be deleted from the high score table
func (client *Client) SetInlineGameScore(inlineMessageId string, editMessage bool, userId int32, score int32, force bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setInlineGameScore",
        },
        Data: map[string]interface{}{
            "inline_message_id": inlineMessageId,
            "edit_message": editMessage,
            "user_id": userId,
            "score": score,
            "force": force,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns the high scores for a game and some part of the high score table in the range of the specified user; for bots only
//
// @param chatId The chat that contains the message with the game
// @param messageId Identifier of the message
// @param userId User identifier
func (client *Client) GetGameHighScores(chatId int64, messageId int64, userId int32) (*GameHighScores, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getGameHighScores",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "user_id": userId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalGameHighScores(result.Data)
}

// Returns game high scores and some part of the high score table in the range of the specified user; for bots only
//
// @param inlineMessageId Inline message identifier
// @param userId User identifier
func (client *Client) GetInlineGameHighScores(inlineMessageId string, userId int32) (*GameHighScores, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getInlineGameHighScores",
        },
        Data: map[string]interface{}{
            "inline_message_id": inlineMessageId,
            "user_id": userId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalGameHighScores(result.Data)
}

// Deletes the default reply markup from a chat. Must be called after a one-time keyboard or a ForceReply reply markup has been used. UpdateChatReplyMarkup will be sent if the reply markup will be changed
//
// @param chatId Chat identifier
// @param messageId The message identifier of the used keyboard
func (client *Client) DeleteChatReplyMarkup(chatId int64, messageId int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteChatReplyMarkup",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Sends a notification about user activity in a chat
//
// @param chatId Chat identifier
// @param action The action description
func (client *Client) SendChatAction(chatId int64, action ChatAction) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendChatAction",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "action": action,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// This method should be called if the chat is opened by the user. Many useful activities depend on the chat being opened or closed (e.g., in supergroups and channels all updates are received only for opened chats)
//
// @param chatId Chat identifier
func (client *Client) OpenChat(chatId int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "openChat",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// This method should be called if the chat is closed by the user. Many useful activities depend on the chat being opened or closed
//
// @param chatId Chat identifier
func (client *Client) CloseChat(chatId int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "closeChat",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// This method should be called if messages are being viewed by the user. Many useful activities depend on whether the messages are currently being viewed or not (e.g., marking messages as read, incrementing a view counter, updating a view counter, removing deleted messages in supergroups and channels)
//
// @param chatId Chat identifier
// @param messageIds The identifiers of the messages being viewed
// @param forceRead True, if messages in closed chats should be marked as read
func (client *Client) ViewMessages(chatId int64, messageIds []int64, forceRead bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "viewMessages",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_ids": messageIds,
            "force_read": forceRead,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// This method should be called if the message content has been opened (e.g., the user has opened a photo, video, document, location or venue, or has listened to an audio file or voice note message). An updateMessageContentOpened update will be generated if something has changed
//
// @param chatId Chat identifier of the message
// @param messageId Identifier of the message with the opened content
func (client *Client) OpenMessageContent(chatId int64, messageId int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "openMessageContent",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Marks all mentions in a chat as read
//
// @param chatId Chat identifier
func (client *Client) ReadAllChatMentions(chatId int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "readAllChatMentions",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns an existing chat corresponding to a given user
//
// @param userId User identifier
// @param force If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect
func (client *Client) CreatePrivateChat(userId int32, force bool) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createPrivateChat",
        },
        Data: map[string]interface{}{
            "user_id": userId,
            "force": force,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Returns an existing chat corresponding to a known basic group
//
// @param basicGroupId Basic group identifier
// @param force If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect
func (client *Client) CreateBasicGroupChat(basicGroupId int32, force bool) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createBasicGroupChat",
        },
        Data: map[string]interface{}{
            "basic_group_id": basicGroupId,
            "force": force,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Returns an existing chat corresponding to a known supergroup or channel
//
// @param supergroupId Supergroup or channel identifier
// @param force If true, the chat will be created without network request. In this case all information about the chat except its type, title and photo can be incorrect
func (client *Client) CreateSupergroupChat(supergroupId int32, force bool) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createSupergroupChat",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "force": force,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Returns an existing chat corresponding to a known secret chat
//
// @param secretChatId Secret chat identifier
func (client *Client) CreateSecretChat(secretChatId int32) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createSecretChat",
        },
        Data: map[string]interface{}{
            "secret_chat_id": secretChatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Creates a new basic group and sends a corresponding messageBasicGroupChatCreate. Returns the newly created chat
//
// @param userIds Identifiers of users to be added to the basic group
// @param title Title of the new basic group; 1-255 characters
func (client *Client) CreateNewBasicGroupChat(userIds []int32, title string) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createNewBasicGroupChat",
        },
        Data: map[string]interface{}{
            "user_ids": userIds,
            "title": title,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Creates a new supergroup or channel and sends a corresponding messageSupergroupChatCreate. Returns the newly created chat
//
// @param title Title of the new chat; 1-255 characters
// @param isChannel True, if a channel chat should be created
// @param description Chat description; 0-255 characters
func (client *Client) CreateNewSupergroupChat(title string, isChannel bool, description string) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createNewSupergroupChat",
        },
        Data: map[string]interface{}{
            "title": title,
            "is_channel": isChannel,
            "description": description,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Creates a new secret chat. Returns the newly created chat
//
// @param userId Identifier of the target user
func (client *Client) CreateNewSecretChat(userId int32) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createNewSecretChat",
        },
        Data: map[string]interface{}{
            "user_id": userId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Creates a new supergroup from an existing basic group and sends a corresponding messageChatUpgradeTo and messageChatUpgradeFrom. Deactivates the original basic group
//
// @param chatId Identifier of the chat to upgrade
func (client *Client) UpgradeBasicGroupChatToSupergroupChat(chatId int64) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "upgradeBasicGroupChatToSupergroupChat",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Changes the chat title. Supported only for basic groups, supergroups and channels. Requires administrator rights in basic groups and the appropriate administrator rights in supergroups and channels. The title will not be changed until the request to the server has been completed
//
// @param chatId Chat identifier
// @param title New title of the chat; 1-255 characters
func (client *Client) SetChatTitle(chatId int64, title string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setChatTitle",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "title": title,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the photo of a chat. Supported only for basic groups, supergroups and channels. Requires administrator rights in basic groups and the appropriate administrator rights in supergroups and channels. The photo will not be changed before request to the server has been completed
//
// @param chatId Chat identifier
// @param photo New chat photo. You can use a zero InputFileId to delete the chat photo. Files that are accessible only by HTTP URL are not acceptable
func (client *Client) SetChatPhoto(chatId int64, photo InputFile) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setChatPhoto",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "photo": photo,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the draft message in a chat
//
// @param chatId Chat identifier
// @param draftMessage New draft message; may be null
func (client *Client) SetChatDraftMessage(chatId int64, draftMessage *DraftMessage) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setChatDraftMessage",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "draft_message": draftMessage,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the pinned state of a chat. You can pin up to GetOption("pinned_chat_count_max") non-secret chats and the same number of secret chats
//
// @param chatId Chat identifier
// @param isPinned New value of is_pinned
func (client *Client) ToggleChatIsPinned(chatId int64, isPinned bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "toggleChatIsPinned",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "is_pinned": isPinned,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes client data associated with a chat
//
// @param chatId Chat identifier
// @param clientData New value of client_data
func (client *Client) SetChatClientData(chatId int64, clientData string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setChatClientData",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "client_data": clientData,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Adds a new member to a chat. Members can't be added to private or secret chats. Members will not be added until the chat state has been synchronized with the server
//
// @param chatId Chat identifier
// @param userId Identifier of the user
// @param forwardLimit The number of earlier messages from the chat to be forwarded to the new member; up to 300. Ignored for supergroups and channels
func (client *Client) AddChatMember(chatId int64, userId int32, forwardLimit int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "addChatMember",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "user_id": userId,
            "forward_limit": forwardLimit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Adds multiple new members to a chat. Currently this option is only available for supergroups and channels. This option can't be used to join a chat. Members can't be added to a channel if it has more than 200 members. Members will not be added until the chat state has been synchronized with the server
//
// @param chatId Chat identifier
// @param userIds Identifiers of the users to be added to the chat
func (client *Client) AddChatMembers(chatId int64, userIds []int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "addChatMembers",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "user_ids": userIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the status of a chat member, needs appropriate privileges. This function is currently not suitable for adding new members to the chat; instead, use addChatMember. The chat member status will not be changed until it has been synchronized with the server
//
// @param chatId Chat identifier
// @param userId User identifier
// @param status The new status of the member in the chat
func (client *Client) SetChatMemberStatus(chatId int64, userId int32, status ChatMemberStatus) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setChatMemberStatus",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "user_id": userId,
            "status": status,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns information about a single member of a chat
//
// @param chatId Chat identifier
// @param userId User identifier
func (client *Client) GetChatMember(chatId int64, userId int32) (*ChatMember, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getChatMember",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "user_id": userId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChatMember(result.Data)
}

// Searches for a specified query in the first name, last name and username of the members of a specified chat. Requires administrator rights in channels
//
// @param chatId Chat identifier
// @param query Query to search for
// @param limit The maximum number of users to be returned
func (client *Client) SearchChatMembers(chatId int64, query string, limit int32) (*ChatMembers, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchChatMembers",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "query": query,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChatMembers(result.Data)
}

// Returns a list of users who are administrators of the chat
//
// @param chatId Chat identifier
func (client *Client) GetChatAdministrators(chatId int64) (*Users, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getChatAdministrators",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUsers(result.Data)
}

// Changes the order of pinned chats
//
// @param chatIds The new list of pinned chats
func (client *Client) SetPinnedChats(chatIds []int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setPinnedChats",
        },
        Data: map[string]interface{}{
            "chat_ids": chatIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Asynchronously downloads a file from the cloud. updateFile will be used to notify about the download progress and successful completion of the download. Returns file state just after the download has been started
//
// @param fileId Identifier of the file to download
// @param priority Priority of the download (1-32). The higher the priority, the earlier the file will be downloaded. If the priorities of two files are equal, then the last one for which downloadFile was called will be downloaded first
func (client *Client) DownloadFile(fileId int32, priority int32) (*File, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "downloadFile",
        },
        Data: map[string]interface{}{
            "file_id": fileId,
            "priority": priority,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalFile(result.Data)
}

// Stops the downloading of a file. If a file has already been downloaded, does nothing
//
// @param fileId Identifier of a file to stop downloading
// @param onlyIfPending Pass true to stop downloading only if it hasn't been started, i.e. request hasn't been sent to server
func (client *Client) CancelDownloadFile(fileId int32, onlyIfPending bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "cancelDownloadFile",
        },
        Data: map[string]interface{}{
            "file_id": fileId,
            "only_if_pending": onlyIfPending,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Asynchronously uploads a file to the cloud without sending it in a message. updateFile will be used to notify about upload progress and successful completion of the upload. The file will not have a persistent remote identifier until it will be sent in a message
//
// @param file File to upload
// @param fileType File type
// @param priority Priority of the upload (1-32). The higher the priority, the earlier the file will be uploaded. If the priorities of two files are equal, then the first one for which uploadFile was called will be uploaded first
func (client *Client) UploadFile(file InputFile, fileType FileType, priority int32) (*File, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "uploadFile",
        },
        Data: map[string]interface{}{
            "file": file,
            "file_type": fileType,
            "priority": priority,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalFile(result.Data)
}

// Stops the uploading of a file. Supported only for files uploaded by using uploadFile. For other files the behavior is undefined
//
// @param fileId Identifier of the file to stop uploading
func (client *Client) CancelUploadFile(fileId int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "cancelUploadFile",
        },
        Data: map[string]interface{}{
            "file_id": fileId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// The next part of a file was generated
//
// @param generationId The identifier of the generation process
// @param expectedSize Expected size of the generated file, in bytes; 0 if unknown
// @param localPrefixSize The number of bytes already generated
func (client *Client) SetFileGenerationProgress(generationId JsonInt64, expectedSize int32, localPrefixSize int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setFileGenerationProgress",
        },
        Data: map[string]interface{}{
            "generation_id": generationId,
            "expected_size": expectedSize,
            "local_prefix_size": localPrefixSize,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Finishes the file generation
//
// @param generationId The identifier of the generation process
// @param error If set, means that file generation has failed and should be terminated
func (client *Client) FinishFileGeneration(generationId JsonInt64, error *Error) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "finishFileGeneration",
        },
        Data: map[string]interface{}{
            "generation_id": generationId,
            "error": error,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Deletes a file from the TDLib file cache
//
// @param fileId Identifier of the file to delete
func (client *Client) DeleteFile(fileId int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteFile",
        },
        Data: map[string]interface{}{
            "file_id": fileId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Generates a new invite link for a chat; the previously generated link is revoked. Available for basic groups, supergroups, and channels. In basic groups this can be called only by the group's creator; in supergroups and channels this requires appropriate administrator rights
//
// @param chatId Chat identifier
func (client *Client) GenerateChatInviteLink(chatId int64) (*ChatInviteLink, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "generateChatInviteLink",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChatInviteLink(result.Data)
}

// Checks the validity of an invite link for a chat and returns information about the corresponding chat
//
// @param inviteLink Invite link to be checked; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/"
func (client *Client) CheckChatInviteLink(inviteLink string) (*ChatInviteLinkInfo, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "checkChatInviteLink",
        },
        Data: map[string]interface{}{
            "invite_link": inviteLink,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChatInviteLinkInfo(result.Data)
}

// Uses an invite link to add the current user to the chat if possible. The new member will not be added until the chat state has been synchronized with the server
//
// @param inviteLink Invite link to import; should begin with "https://t.me/joinchat/", "https://telegram.me/joinchat/", or "https://telegram.dog/joinchat/"
func (client *Client) JoinChatByInviteLink(inviteLink string) (*Chat, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "joinChatByInviteLink",
        },
        Data: map[string]interface{}{
            "invite_link": inviteLink,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChat(result.Data)
}

// Creates a new call
//
// @param userId Identifier of the user to be called
// @param protocol Description of the call protocols supported by the client
func (client *Client) CreateCall(userId int32, protocol *CallProtocol) (*CallId, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createCall",
        },
        Data: map[string]interface{}{
            "user_id": userId,
            "protocol": protocol,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalCallId(result.Data)
}

// Accepts an incoming call
//
// @param callId Call identifier
// @param protocol Description of the call protocols supported by the client
func (client *Client) AcceptCall(callId int32, protocol *CallProtocol) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "acceptCall",
        },
        Data: map[string]interface{}{
            "call_id": callId,
            "protocol": protocol,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Discards a call
//
// @param callId Call identifier
// @param isDisconnected True, if the user was disconnected
// @param duration The call duration, in seconds
// @param connectionId Identifier of the connection used during the call
func (client *Client) DiscardCall(callId int32, isDisconnected bool, duration int32, connectionId JsonInt64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "discardCall",
        },
        Data: map[string]interface{}{
            "call_id": callId,
            "is_disconnected": isDisconnected,
            "duration": duration,
            "connection_id": connectionId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Sends a call rating
//
// @param callId Call identifier
// @param rating Call rating; 1-5
// @param comment An optional user comment if the rating is less than 5
func (client *Client) SendCallRating(callId int32, rating int32, comment string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendCallRating",
        },
        Data: map[string]interface{}{
            "call_id": callId,
            "rating": rating,
            "comment": comment,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Sends debug information for a call
//
// @param callId Call identifier
// @param debugInformation Debug information in application-specific format
func (client *Client) SendCallDebugInformation(callId int32, debugInformation string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendCallDebugInformation",
        },
        Data: map[string]interface{}{
            "call_id": callId,
            "debug_information": debugInformation,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Adds a user to the blacklist
//
// @param userId User identifier
func (client *Client) BlockUser(userId int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "blockUser",
        },
        Data: map[string]interface{}{
            "user_id": userId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Removes a user from the blacklist
//
// @param userId User identifier
func (client *Client) UnblockUser(userId int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "unblockUser",
        },
        Data: map[string]interface{}{
            "user_id": userId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns users that were blocked by the current user
//
// @param offset Number of users to skip in the result; must be non-negative
// @param limit Maximum number of users to return; up to 100
func (client *Client) GetBlockedUsers(offset int32, limit int32) (*Users, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getBlockedUsers",
        },
        Data: map[string]interface{}{
            "offset": offset,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUsers(result.Data)
}

// Adds new contacts or edits existing contacts; contacts' user identifiers are ignored
//
// @param contacts The list of contacts to import or edit
func (client *Client) ImportContacts(contacts []*Contact) (*ImportedContacts, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "importContacts",
        },
        Data: map[string]interface{}{
            "contacts": contacts,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalImportedContacts(result.Data)
}

// Searches for the specified query in the first names, last names and usernames of the known user contacts
//
// @param query Query to search for; can be empty to return all contacts
// @param limit Maximum number of users to be returned
func (client *Client) SearchContacts(query string, limit int32) (*Users, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchContacts",
        },
        Data: map[string]interface{}{
            "query": query,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUsers(result.Data)
}

// Removes users from the contacts list
//
// @param userIds Identifiers of users to be deleted
func (client *Client) RemoveContacts(userIds []int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "removeContacts",
        },
        Data: map[string]interface{}{
            "user_ids": userIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns the total number of imported contacts
func (client *Client) GetImportedContactCount() (*Count, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getImportedContactCount",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalCount(result.Data)
}

// Changes imported contacts using the list of current user contacts saved on the device. Imports newly added contacts and, if at least the file database is enabled, deletes recently deleted contacts. Query result depends on the result of the previous query, so only one query is possible at the same time
//
// @param contacts The new list of contacts
func (client *Client) ChangeImportedContacts(contacts []*Contact) (*ImportedContacts, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "changeImportedContacts",
        },
        Data: map[string]interface{}{
            "contacts": contacts,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalImportedContacts(result.Data)
}

// Clears all imported contacts
func (client *Client) ClearImportedContacts() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "clearImportedContacts",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns the profile photos of a user. The result of this query may be outdated: some photos might have been deleted already
//
// @param userId User identifier
// @param offset The number of photos to skip; must be non-negative
// @param limit Maximum number of photos to be returned; up to 100
func (client *Client) GetUserProfilePhotos(userId int32, offset int32, limit int32) (*UserProfilePhotos, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getUserProfilePhotos",
        },
        Data: map[string]interface{}{
            "user_id": userId,
            "offset": offset,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUserProfilePhotos(result.Data)
}

// Returns stickers from the installed sticker sets that correspond to a given emoji. If the emoji is not empty, favorite and recently used stickers may also be returned
//
// @param emoji String representation of emoji. If empty, returns all known installed stickers
// @param limit Maximum number of stickers to be returned
func (client *Client) GetStickers(emoji string, limit int32) (*Stickers, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getStickers",
        },
        Data: map[string]interface{}{
            "emoji": emoji,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickers(result.Data)
}

// Searches for stickers from public sticker sets that correspond to a given emoji
//
// @param emoji String representation of emoji; must be non-empty
// @param limit Maximum number of stickers to be returned
func (client *Client) SearchStickers(emoji string, limit int32) (*Stickers, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchStickers",
        },
        Data: map[string]interface{}{
            "emoji": emoji,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickers(result.Data)
}

// Returns a list of installed sticker sets
//
// @param isMasks Pass true to return mask sticker sets; pass false to return ordinary sticker sets
func (client *Client) GetInstalledStickerSets(isMasks bool) (*StickerSets, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getInstalledStickerSets",
        },
        Data: map[string]interface{}{
            "is_masks": isMasks,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSets(result.Data)
}

// Returns a list of archived sticker sets
//
// @param isMasks Pass true to return mask stickers sets; pass false to return ordinary sticker sets
// @param offsetStickerSetId Identifier of the sticker set from which to return the result
// @param limit Maximum number of sticker sets to return
func (client *Client) GetArchivedStickerSets(isMasks bool, offsetStickerSetId JsonInt64, limit int32) (*StickerSets, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getArchivedStickerSets",
        },
        Data: map[string]interface{}{
            "is_masks": isMasks,
            "offset_sticker_set_id": offsetStickerSetId,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSets(result.Data)
}

// Returns a list of trending sticker sets
func (client *Client) GetTrendingStickerSets() (*StickerSets, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getTrendingStickerSets",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSets(result.Data)
}

// Returns a list of sticker sets attached to a file. Currently only photos and videos can have attached sticker sets
//
// @param fileId File identifier
func (client *Client) GetAttachedStickerSets(fileId int32) (*StickerSets, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getAttachedStickerSets",
        },
        Data: map[string]interface{}{
            "file_id": fileId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSets(result.Data)
}

// Returns information about a sticker set by its identifier
//
// @param setId Identifier of the sticker set
func (client *Client) GetStickerSet(setId JsonInt64) (*StickerSet, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getStickerSet",
        },
        Data: map[string]interface{}{
            "set_id": setId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSet(result.Data)
}

// Searches for a sticker set by its name
//
// @param name Name of the sticker set
func (client *Client) SearchStickerSet(name string) (*StickerSet, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchStickerSet",
        },
        Data: map[string]interface{}{
            "name": name,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSet(result.Data)
}

// Searches for installed sticker sets by looking for specified query in their title and name
//
// @param isMasks Pass true to return mask sticker sets; pass false to return ordinary sticker sets
// @param query Query to search for
// @param limit Maximum number of sticker sets to return
func (client *Client) SearchInstalledStickerSets(isMasks bool, query string, limit int32) (*StickerSets, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchInstalledStickerSets",
        },
        Data: map[string]interface{}{
            "is_masks": isMasks,
            "query": query,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSets(result.Data)
}

// Searches for ordinary sticker sets by looking for specified query in their title and name. Excludes installed sticker sets from the results
//
// @param query Query to search for
func (client *Client) SearchStickerSets(query string) (*StickerSets, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchStickerSets",
        },
        Data: map[string]interface{}{
            "query": query,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSets(result.Data)
}

// Installs/uninstalls or activates/archives a sticker set
//
// @param setId Identifier of the sticker set
// @param isInstalled The new value of is_installed
// @param isArchived The new value of is_archived. A sticker set can't be installed and archived simultaneously
func (client *Client) ChangeStickerSet(setId JsonInt64, isInstalled bool, isArchived bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "changeStickerSet",
        },
        Data: map[string]interface{}{
            "set_id": setId,
            "is_installed": isInstalled,
            "is_archived": isArchived,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Informs the server that some trending sticker sets have been viewed by the user
//
// @param stickerSetIds Identifiers of viewed trending sticker sets
func (client *Client) ViewTrendingStickerSets(stickerSetIds []JsonInt64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "viewTrendingStickerSets",
        },
        Data: map[string]interface{}{
            "sticker_set_ids": stickerSetIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the order of installed sticker sets
//
// @param isMasks Pass true to change the order of mask sticker sets; pass false to change the order of ordinary sticker sets
// @param stickerSetIds Identifiers of installed sticker sets in the new correct order
func (client *Client) ReorderInstalledStickerSets(isMasks bool, stickerSetIds []JsonInt64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "reorderInstalledStickerSets",
        },
        Data: map[string]interface{}{
            "is_masks": isMasks,
            "sticker_set_ids": stickerSetIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns a list of recently used stickers
//
// @param isAttached Pass true to return stickers and masks that were recently attached to photos or video files; pass false to return recently sent stickers
func (client *Client) GetRecentStickers(isAttached bool) (*Stickers, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getRecentStickers",
        },
        Data: map[string]interface{}{
            "is_attached": isAttached,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickers(result.Data)
}

// Manually adds a new sticker to the list of recently used stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
//
// @param isAttached Pass true to add the sticker to the list of stickers recently attached to photo or video files; pass false to add the sticker to the list of recently sent stickers
// @param sticker Sticker file to add
func (client *Client) AddRecentSticker(isAttached bool, sticker InputFile) (*Stickers, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "addRecentSticker",
        },
        Data: map[string]interface{}{
            "is_attached": isAttached,
            "sticker": sticker,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickers(result.Data)
}

// Removes a sticker from the list of recently used stickers
//
// @param isAttached Pass true to remove the sticker from the list of stickers recently attached to photo or video files; pass false to remove the sticker from the list of recently sent stickers
// @param sticker Sticker file to delete
func (client *Client) RemoveRecentSticker(isAttached bool, sticker InputFile) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "removeRecentSticker",
        },
        Data: map[string]interface{}{
            "is_attached": isAttached,
            "sticker": sticker,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Clears the list of recently used stickers
//
// @param isAttached Pass true to clear the list of stickers recently attached to photo or video files; pass false to clear the list of recently sent stickers
func (client *Client) ClearRecentStickers(isAttached bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "clearRecentStickers",
        },
        Data: map[string]interface{}{
            "is_attached": isAttached,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns favorite stickers
func (client *Client) GetFavoriteStickers() (*Stickers, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getFavoriteStickers",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickers(result.Data)
}

// Adds a new sticker to the list of favorite stickers. The new sticker is added to the top of the list. If the sticker was already in the list, it is removed from the list first. Only stickers belonging to a sticker set can be added to this list
//
// @param sticker Sticker file to add
func (client *Client) AddFavoriteSticker(sticker InputFile) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "addFavoriteSticker",
        },
        Data: map[string]interface{}{
            "sticker": sticker,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Removes a sticker from the list of favorite stickers
//
// @param sticker Sticker file to delete from the list
func (client *Client) RemoveFavoriteSticker(sticker InputFile) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "removeFavoriteSticker",
        },
        Data: map[string]interface{}{
            "sticker": sticker,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns emoji corresponding to a sticker
//
// @param sticker Sticker file identifier
func (client *Client) GetStickerEmojis(sticker InputFile) (*StickerEmojis, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getStickerEmojis",
        },
        Data: map[string]interface{}{
            "sticker": sticker,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerEmojis(result.Data)
}

// Returns saved animations
func (client *Client) GetSavedAnimations() (*Animations, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getSavedAnimations",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalAnimations(result.Data)
}

// Manually adds a new animation to the list of saved animations. The new animation is added to the beginning of the list. If the animation was already in the list, it is removed first. Only non-secret video animations with MIME type "video/mp4" can be added to the list
//
// @param animation The animation file to be added. Only animations known to the server (i.e. successfully sent via a message) can be added to the list
func (client *Client) AddSavedAnimation(animation InputFile) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "addSavedAnimation",
        },
        Data: map[string]interface{}{
            "animation": animation,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Removes an animation from the list of saved animations
//
// @param animation Animation file to be removed
func (client *Client) RemoveSavedAnimation(animation InputFile) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "removeSavedAnimation",
        },
        Data: map[string]interface{}{
            "animation": animation,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns up to 20 recently used inline bots in the order of their last usage
func (client *Client) GetRecentInlineBots() (*Users, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getRecentInlineBots",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUsers(result.Data)
}

// Searches for recently used hashtags by their prefix
//
// @param prefix Hashtag prefix to search for
// @param limit Maximum number of hashtags to be returned
func (client *Client) SearchHashtags(prefix string, limit int32) (*Hashtags, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "searchHashtags",
        },
        Data: map[string]interface{}{
            "prefix": prefix,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalHashtags(result.Data)
}

// Removes a hashtag from the list of recently used hashtags
//
// @param hashtag Hashtag to delete
func (client *Client) RemoveRecentHashtag(hashtag string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "removeRecentHashtag",
        },
        Data: map[string]interface{}{
            "hashtag": hashtag,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns a web page preview by the text of the message. Do not call this function too often. Returns a 404 error if the web page has no preview
//
// @param text Message text with formatting
func (client *Client) GetWebPagePreview(text *FormattedText) (*WebPage, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getWebPagePreview",
        },
        Data: map[string]interface{}{
            "text": text,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalWebPage(result.Data)
}

// Returns an instant view version of a web page if available. Returns a 404 error if the web page has no instant view page
//
// @param url The web page URL
// @param forceFull If true, the full instant view for the web page will be returned
func (client *Client) GetWebPageInstantView(url string, forceFull bool) (*WebPageInstantView, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getWebPageInstantView",
        },
        Data: map[string]interface{}{
            "url": url,
            "force_full": forceFull,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalWebPageInstantView(result.Data)
}

// Returns the notification settings for a given scope
//
// @param scope Scope for which to return the notification settings information
func (client *Client) GetNotificationSettings(scope NotificationSettingsScope) (*NotificationSettings, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getNotificationSettings",
        },
        Data: map[string]interface{}{
            "scope": scope,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalNotificationSettings(result.Data)
}

// Changes notification settings for a given scope
//
// @param scope Scope for which to change the notification settings
// @param notificationSettings The new notification settings for the given scope
func (client *Client) SetNotificationSettings(scope NotificationSettingsScope, notificationSettings *NotificationSettings) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setNotificationSettings",
        },
        Data: map[string]interface{}{
            "scope": scope,
            "notification_settings": notificationSettings,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Resets all notification settings to their default values. By default, the only muted chats are supergroups, the sound is set to "default" and message previews are shown
func (client *Client) ResetAllNotificationSettings() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "resetAllNotificationSettings",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Uploads a new profile photo for the current user. If something changes, updateUser will be sent
//
// @param photo Profile photo to set. inputFileId and inputFileRemote may still be unsupported
func (client *Client) SetProfilePhoto(photo InputFile) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setProfilePhoto",
        },
        Data: map[string]interface{}{
            "photo": photo,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Deletes a profile photo. If something changes, updateUser will be sent
//
// @param profilePhotoId Identifier of the profile photo to delete
func (client *Client) DeleteProfilePhoto(profilePhotoId JsonInt64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteProfilePhoto",
        },
        Data: map[string]interface{}{
            "profile_photo_id": profilePhotoId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the first and last name of the current user. If something changes, updateUser will be sent
//
// @param firstName The new value of the first name for the user; 1-255 characters
// @param lastName The new value of the optional last name for the user; 0-255 characters
func (client *Client) SetName(firstName string, lastName string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setName",
        },
        Data: map[string]interface{}{
            "first_name": firstName,
            "last_name": lastName,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the bio of the current user
//
// @param bio The new value of the user bio; 0-70 characters without line feeds
func (client *Client) SetBio(bio string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setBio",
        },
        Data: map[string]interface{}{
            "bio": bio,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the username of the current user. If something changes, updateUser will be sent
//
// @param username The new value of the username. Use an empty string to remove the username
func (client *Client) SetUsername(username string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setUsername",
        },
        Data: map[string]interface{}{
            "username": username,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the phone number of the user and sends an authentication code to the user's new phone number. On success, returns information about the sent code
//
// @param phoneNumber The new phone number of the user in international format
// @param allowFlashCall Pass true if the code can be sent via flash call to the specified phone number
// @param isCurrentPhoneNumber Pass true if the phone number is used on the current device. Ignored if allow_flash_call is false
func (client *Client) ChangePhoneNumber(phoneNumber string, allowFlashCall bool, isCurrentPhoneNumber bool) (*AuthenticationCodeInfo, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "changePhoneNumber",
        },
        Data: map[string]interface{}{
            "phone_number": phoneNumber,
            "allow_flash_call": allowFlashCall,
            "is_current_phone_number": isCurrentPhoneNumber,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalAuthenticationCodeInfo(result.Data)
}

// Re-sends the authentication code sent to confirm a new phone number for the user. Works only if the previously received authenticationCodeInfo next_code_type was not null
func (client *Client) ResendChangePhoneNumberCode() (*AuthenticationCodeInfo, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "resendChangePhoneNumberCode",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalAuthenticationCodeInfo(result.Data)
}

// Checks the authentication code sent to confirm a new phone number of the user
//
// @param code Verification code received by SMS, phone call or flash call
func (client *Client) CheckChangePhoneNumberCode(code string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "checkChangePhoneNumberCode",
        },
        Data: map[string]interface{}{
            "code": code,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns all active sessions of the current user
func (client *Client) GetActiveSessions() (*Sessions, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getActiveSessions",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalSessions(result.Data)
}

// Terminates a session of the current user
//
// @param sessionId Session identifier
func (client *Client) TerminateSession(sessionId JsonInt64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "terminateSession",
        },
        Data: map[string]interface{}{
            "session_id": sessionId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Terminates all other sessions of the current user
func (client *Client) TerminateAllOtherSessions() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "terminateAllOtherSessions",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns all website where the current user used Telegram to log in
func (client *Client) GetConnectedWebsites() (*ConnectedWebsites, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getConnectedWebsites",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalConnectedWebsites(result.Data)
}

// Disconnects website from the current user's Telegram account
//
// @param websiteId Website identifier
func (client *Client) DisconnectWebsite(websiteId JsonInt64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "disconnectWebsite",
        },
        Data: map[string]interface{}{
            "website_id": websiteId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Disconnects all websites from the current user's Telegram account
func (client *Client) DisconnectAllWebsites() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "disconnectAllWebsites",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Toggles the "All members are admins" setting in basic groups; requires creator privileges in the group
//
// @param basicGroupId Identifier of the basic group
// @param everyoneIsAdministrator New value of everyone_is_administrator
func (client *Client) ToggleBasicGroupAdministrators(basicGroupId int32, everyoneIsAdministrator bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "toggleBasicGroupAdministrators",
        },
        Data: map[string]interface{}{
            "basic_group_id": basicGroupId,
            "everyone_is_administrator": everyoneIsAdministrator,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the username of a supergroup or channel, requires creator privileges in the supergroup or channel
//
// @param supergroupId Identifier of the supergroup or channel
// @param username New value of the username. Use an empty string to remove the username
func (client *Client) SetSupergroupUsername(supergroupId int32, username string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setSupergroupUsername",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "username": username,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the sticker set of a supergroup; requires appropriate rights in the supergroup
//
// @param supergroupId Identifier of the supergroup
// @param stickerSetId New value of the supergroup sticker set identifier. Use 0 to remove the supergroup sticker set
func (client *Client) SetSupergroupStickerSet(supergroupId int32, stickerSetId JsonInt64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setSupergroupStickerSet",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "sticker_set_id": stickerSetId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Toggles whether all members of a supergroup can add new members; requires appropriate administrator rights in the supergroup.
//
// @param supergroupId Identifier of the supergroup
// @param anyoneCanInvite New value of anyone_can_invite
func (client *Client) ToggleSupergroupInvites(supergroupId int32, anyoneCanInvite bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "toggleSupergroupInvites",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "anyone_can_invite": anyoneCanInvite,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Toggles sender signatures messages sent in a channel; requires appropriate administrator rights in the channel.
//
// @param supergroupId Identifier of the channel
// @param signMessages New value of sign_messages
func (client *Client) ToggleSupergroupSignMessages(supergroupId int32, signMessages bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "toggleSupergroupSignMessages",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "sign_messages": signMessages,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Toggles whether the message history of a supergroup is available to new members; requires appropriate administrator rights in the supergroup.
//
// @param supergroupId The identifier of the supergroup
// @param isAllHistoryAvailable The new value of is_all_history_available
func (client *Client) ToggleSupergroupIsAllHistoryAvailable(supergroupId int32, isAllHistoryAvailable bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "toggleSupergroupIsAllHistoryAvailable",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "is_all_history_available": isAllHistoryAvailable,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes information about a supergroup or channel; requires appropriate administrator rights
//
// @param supergroupId Identifier of the supergroup or channel
// @param description New supergroup or channel description; 0-255 characters
func (client *Client) SetSupergroupDescription(supergroupId int32, description string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setSupergroupDescription",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "description": description,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Pins a message in a supergroup or channel; requires appropriate administrator rights in the supergroup or channel
//
// @param supergroupId Identifier of the supergroup or channel
// @param messageId Identifier of the new pinned message
// @param disableNotification True, if there should be no notification about the pinned message
func (client *Client) PinSupergroupMessage(supergroupId int32, messageId int64, disableNotification bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "pinSupergroupMessage",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "message_id": messageId,
            "disable_notification": disableNotification,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Removes the pinned message from a supergroup or channel; requires appropriate administrator rights in the supergroup or channel
//
// @param supergroupId Identifier of the supergroup or channel
func (client *Client) UnpinSupergroupMessage(supergroupId int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "unpinSupergroupMessage",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Reports some messages from a user in a supergroup as spam
//
// @param supergroupId Supergroup identifier
// @param userId User identifier
// @param messageIds Identifiers of messages sent in the supergroup by the user. This list must be non-empty
func (client *Client) ReportSupergroupSpam(supergroupId int32, userId int32, messageIds []int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "reportSupergroupSpam",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "user_id": userId,
            "message_ids": messageIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns information about members or banned users in a supergroup or channel. Can be used only if SupergroupFullInfo.can_get_members == true; additionally, administrator privileges may be required for some filters
//
// @param supergroupId Identifier of the supergroup or channel
// @param filter The type of users to return. By default, supergroupMembersRecent
// @param offset Number of users to skip
// @param limit The maximum number of users be returned; up to 200
func (client *Client) GetSupergroupMembers(supergroupId int32, filter SupergroupMembersFilter, offset int32, limit int32) (*ChatMembers, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getSupergroupMembers",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
            "filter": filter,
            "offset": offset,
            "limit": limit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChatMembers(result.Data)
}

// Deletes a supergroup or channel along with all messages in the corresponding chat. This will release the supergroup or channel username and remove all members; requires creator privileges in the supergroup or channel. Chats with more than 1000 members can't be deleted using this method
//
// @param supergroupId Identifier of the supergroup or channel
func (client *Client) DeleteSupergroup(supergroupId int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteSupergroup",
        },
        Data: map[string]interface{}{
            "supergroup_id": supergroupId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Closes a secret chat, effectively transfering its state to secretChatStateClosed
//
// @param secretChatId Secret chat identifier
func (client *Client) CloseSecretChat(secretChatId int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "closeSecretChat",
        },
        Data: map[string]interface{}{
            "secret_chat_id": secretChatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns a list of service actions taken by chat members and administrators in the last 48 hours. Available only in supergroups and channels. Requires administrator rights. Returns results in reverse chronological order (i. e., in order of decreasing event_id)
//
// @param chatId Chat identifier
// @param query Search query by which to filter events
// @param fromEventId Identifier of an event from which to return results. Use 0 to get results from the latest events
// @param limit Maximum number of events to return; up to 100
// @param filters The types of events to return. By default, all types will be returned
// @param userIds User identifiers by which to filter events. By default, events relating to all users will be returned
func (client *Client) GetChatEventLog(chatId int64, query string, fromEventId JsonInt64, limit int32, filters *ChatEventLogFilters, userIds []int32) (*ChatEvents, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getChatEventLog",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "query": query,
            "from_event_id": fromEventId,
            "limit": limit,
            "filters": filters,
            "user_ids": userIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChatEvents(result.Data)
}

// Returns an invoice payment form. This method should be called when the user presses inlineKeyboardButtonBuy
//
// @param chatId Chat identifier of the Invoice message
// @param messageId Message identifier
func (client *Client) GetPaymentForm(chatId int64, messageId int64) (*PaymentForm, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getPaymentForm",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalPaymentForm(result.Data)
}

// Validates the order information provided by a user and returns the available shipping options for a flexible invoice
//
// @param chatId Chat identifier of the Invoice message
// @param messageId Message identifier
// @param orderInfo The order information, provided by the user
// @param allowSave True, if the order information can be saved
func (client *Client) ValidateOrderInfo(chatId int64, messageId int64, orderInfo *OrderInfo, allowSave bool) (*ValidatedOrderInfo, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "validateOrderInfo",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "order_info": orderInfo,
            "allow_save": allowSave,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalValidatedOrderInfo(result.Data)
}

// Sends a filled-out payment form to the bot for final verification
//
// @param chatId Chat identifier of the Invoice message
// @param messageId Message identifier
// @param orderInfoId Identifier returned by ValidateOrderInfo, or an empty string
// @param shippingOptionId Identifier of a chosen shipping option, if applicable
// @param credentials The credentials chosen by user for payment
func (client *Client) SendPaymentForm(chatId int64, messageId int64, orderInfoId string, shippingOptionId string, credentials InputCredentials) (*PaymentResult, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendPaymentForm",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
            "order_info_id": orderInfoId,
            "shipping_option_id": shippingOptionId,
            "credentials": credentials,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalPaymentResult(result.Data)
}

// Returns information about a successful payment
//
// @param chatId Chat identifier of the PaymentSuccessful message
// @param messageId Message identifier
func (client *Client) GetPaymentReceipt(chatId int64, messageId int64) (*PaymentReceipt, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getPaymentReceipt",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "message_id": messageId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalPaymentReceipt(result.Data)
}

// Returns saved order info, if any
func (client *Client) GetSavedOrderInfo() (*OrderInfo, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getSavedOrderInfo",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOrderInfo(result.Data)
}

// Deletes saved order info
func (client *Client) DeleteSavedOrderInfo() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteSavedOrderInfo",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Deletes saved credentials for all payment provider bots
func (client *Client) DeleteSavedCredentials() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteSavedCredentials",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns a user that can be contacted to get support
func (client *Client) GetSupportUser() (*User, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getSupportUser",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUser(result.Data)
}

// Returns background wallpapers
func (client *Client) GetWallpapers() (*Wallpapers, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getWallpapers",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalWallpapers(result.Data)
}

// Registers the currently used device for receiving push notifications
//
// @param deviceToken Device token
// @param otherUserIds List of at most 100 user identifiers of other users currently using the client
func (client *Client) RegisterDevice(deviceToken DeviceToken, otherUserIds []int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "registerDevice",
        },
        Data: map[string]interface{}{
            "device_token": deviceToken,
            "other_user_ids": otherUserIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns t.me URLs recently visited by a newly registered user
//
// @param referrer Google Play referrer to identify the user
func (client *Client) GetRecentlyVisitedTMeUrls(referrer string) (*TMeUrls, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getRecentlyVisitedTMeUrls",
        },
        Data: map[string]interface{}{
            "referrer": referrer,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTMeUrls(result.Data)
}

// Changes user privacy settings
//
// @param setting The privacy setting
// @param rules The new privacy rules
func (client *Client) SetUserPrivacySettingRules(setting UserPrivacySetting, rules *UserPrivacySettingRules) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setUserPrivacySettingRules",
        },
        Data: map[string]interface{}{
            "setting": setting,
            "rules": rules,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns the current privacy settings
//
// @param setting The privacy setting
func (client *Client) GetUserPrivacySettingRules(setting UserPrivacySetting) (*UserPrivacySettingRules, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getUserPrivacySettingRules",
        },
        Data: map[string]interface{}{
            "setting": setting,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalUserPrivacySettingRules(result.Data)
}

// Returns the value of an option by its name. (Check the list of available options on https://core.telegram.org/tdlib/options.) Can be called before authorization
//
// @param name The name of the option
func (client *Client) GetOption(name string) (OptionValue, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getOption",
        },
        Data: map[string]interface{}{
            "name": name,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    switch result.Type {
    case TypeOptionValueBoolean:
        return UnmarshalOptionValueBoolean(result.Data)

    case TypeOptionValueEmpty:
        return UnmarshalOptionValueEmpty(result.Data)

    case TypeOptionValueInteger:
        return UnmarshalOptionValueInteger(result.Data)

    case TypeOptionValueString:
        return UnmarshalOptionValueString(result.Data)

    default:
        return nil, errors.New("invalid type")
   }
}

// Sets the value of an option. (Check the list of available options on https://core.telegram.org/tdlib/options.) Only writable options can be set. Can be called before authorization
//
// @param name The name of the option
// @param value The new value of the option
func (client *Client) SetOption(name string, value OptionValue) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setOption",
        },
        Data: map[string]interface{}{
            "name": name,
            "value": value,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Changes the period of inactivity after which the account of the current user will automatically be deleted
//
// @param ttl New account TTL
func (client *Client) SetAccountTtl(ttl *AccountTtl) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setAccountTtl",
        },
        Data: map[string]interface{}{
            "ttl": ttl,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns the period of inactivity after which the account of the current user will automatically be deleted
func (client *Client) GetAccountTtl() (*AccountTtl, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getAccountTtl",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalAccountTtl(result.Data)
}

// Deletes the account of the current user, deleting all information associated with the user from the server. The phone number of the account can be used to create a new account
//
// @param reason The reason why the account was deleted; optional
func (client *Client) DeleteAccount(reason string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "deleteAccount",
        },
        Data: map[string]interface{}{
            "reason": reason,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns information on whether the current chat can be reported as spam
//
// @param chatId Chat identifier
func (client *Client) GetChatReportSpamState(chatId int64) (*ChatReportSpamState, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getChatReportSpamState",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalChatReportSpamState(result.Data)
}

// Used to let the server know whether a chat is spam or not. Can be used only if ChatReportSpamState.can_report_spam is true. After this request, ChatReportSpamState.can_report_spam becomes false forever
//
// @param chatId Chat identifier
// @param isSpamChat If true, the chat will be reported as spam; otherwise it will be marked as not spam
func (client *Client) ChangeChatReportSpamState(chatId int64, isSpamChat bool) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "changeChatReportSpamState",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "is_spam_chat": isSpamChat,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Reports a chat to the Telegram moderators. Supported only for supergroups, channels, or private chats with bots, since other chats can't be checked by moderators
//
// @param chatId Chat identifier
// @param reason The reason for reporting the chat
// @param messageIds Identifiers of reported messages, if any
func (client *Client) ReportChat(chatId int64, reason ChatReportReason, messageIds []int64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "reportChat",
        },
        Data: map[string]interface{}{
            "chat_id": chatId,
            "reason": reason,
            "message_ids": messageIds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns storage usage statistics
//
// @param chatLimit Maximum number of chats with the largest storage usage for which separate statistics should be returned. All other chats will be grouped in entries with chat_id == 0. If the chat info database is not used, the chat_limit is ignored and is always set to 0
func (client *Client) GetStorageStatistics(chatLimit int32) (*StorageStatistics, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getStorageStatistics",
        },
        Data: map[string]interface{}{
            "chat_limit": chatLimit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStorageStatistics(result.Data)
}

// Quickly returns approximate storage usage statistics
func (client *Client) GetStorageStatisticsFast() (*StorageStatisticsFast, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getStorageStatisticsFast",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStorageStatisticsFast(result.Data)
}

// Optimizes storage usage, i.e. deletes some files and returns new storage usage statistics. Secret thumbnails can't be deleted
//
// @param size Limit on the total size of files after deletion. Pass -1 to use the default limit
// @param ttl Limit on the time that has passed since the last time a file was accessed (or creation time for some filesystems). Pass -1 to use the default limit
// @param count Limit on the total count of files after deletion. Pass -1 to use the default limit
// @param immunityDelay The amount of time after the creation of a file during which it can't be deleted, in seconds. Pass -1 to use the default value
// @param fileTypes If not empty, only files with the given type(s) are considered. By default, all types except thumbnails, profile photos, stickers and wallpapers are deleted
// @param chatIds If not empty, only files from the given chats are considered. Use 0 as chat identifier to delete files not belonging to any chat (e.g., profile photos)
// @param excludeChatIds If not empty, files from the given chats are excluded. Use 0 as chat identifier to exclude all files not belonging to any chat (e.g., profile photos)
// @param chatLimit Same as in getStorageStatistics. Affects only returned statistics
func (client *Client) OptimizeStorage(size int64, ttl int32, count int32, immunityDelay int32, fileTypes []FileType, chatIds []int64, excludeChatIds []int64, chatLimit int32) (*StorageStatistics, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "optimizeStorage",
        },
        Data: map[string]interface{}{
            "size": size,
            "ttl": ttl,
            "count": count,
            "immunity_delay": immunityDelay,
            "file_types": fileTypes,
            "chat_ids": chatIds,
            "exclude_chat_ids": excludeChatIds,
            "chat_limit": chatLimit,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStorageStatistics(result.Data)
}

// Sets the current network type. Can be called before authorization. Calling this method forces all network connections to reopen, mitigating the delay in switching between different networks, so it should be called whenever the network is changed, even if the network type remains the same. Network type is used to check whether the library can use the network at all and also for collecting detailed network data usage statistics
//
// @param typeParam The new network type. By default, networkTypeOther
func (client *Client) SetNetworkType(typeParam NetworkType) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setNetworkType",
        },
        Data: map[string]interface{}{
            "type": typeParam,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns network data usage statistics. Can be called before authorization
//
// @param onlyCurrent If true, returns only data for the current library launch
func (client *Client) GetNetworkStatistics(onlyCurrent bool) (*NetworkStatistics, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getNetworkStatistics",
        },
        Data: map[string]interface{}{
            "only_current": onlyCurrent,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalNetworkStatistics(result.Data)
}

// Adds the specified data to data usage statistics. Can be called before authorization
//
// @param entry The network statistics entry with the data to be added to statistics
func (client *Client) AddNetworkStatistics(entry NetworkStatisticsEntry) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "addNetworkStatistics",
        },
        Data: map[string]interface{}{
            "entry": entry,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Resets all network data usage statistics to zero. Can be called before authorization
func (client *Client) ResetNetworkStatistics() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "resetNetworkStatistics",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Informs the server about the number of pending bot updates if they haven't been processed for a long time; for bots only
//
// @param pendingUpdateCount The number of pending updates
// @param errorMessage The last error message
func (client *Client) SetBotUpdatesStatus(pendingUpdateCount int32, errorMessage string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setBotUpdatesStatus",
        },
        Data: map[string]interface{}{
            "pending_update_count": pendingUpdateCount,
            "error_message": errorMessage,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Uploads a PNG image with a sticker; for bots only; returns the uploaded file
//
// @param userId Sticker file owner
// @param pngSticker PNG image with the sticker; must be up to 512 kB in size and fit in 512x512 square
func (client *Client) UploadStickerFile(userId int32, pngSticker InputFile) (*File, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "uploadStickerFile",
        },
        Data: map[string]interface{}{
            "user_id": userId,
            "png_sticker": pngSticker,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalFile(result.Data)
}

// Creates a new sticker set; for bots only. Returns the newly created sticker set
//
// @param userId Sticker set owner
// @param title Sticker set title; 1-64 characters
// @param name Sticker set name. Can contain only English letters, digits and underscores. Must end with *"_by_<bot username>"* (*<bot_username>* is case insensitive); 1-64 characters
// @param isMasks True, if stickers are masks
// @param stickers List of stickers to be added to the set
func (client *Client) CreateNewStickerSet(userId int32, title string, name string, isMasks bool, stickers []*InputSticker) (*StickerSet, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "createNewStickerSet",
        },
        Data: map[string]interface{}{
            "user_id": userId,
            "title": title,
            "name": name,
            "is_masks": isMasks,
            "stickers": stickers,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSet(result.Data)
}

// Adds a new sticker to a set; for bots only. Returns the sticker set
//
// @param userId Sticker set owner
// @param name Sticker set name
// @param sticker Sticker to add to the set
func (client *Client) AddStickerToSet(userId int32, name string, sticker *InputSticker) (*StickerSet, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "addStickerToSet",
        },
        Data: map[string]interface{}{
            "user_id": userId,
            "name": name,
            "sticker": sticker,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalStickerSet(result.Data)
}

// Changes the position of a sticker in the set to which it belongs; for bots only. The sticker set must have been created by the bot
//
// @param sticker Sticker
// @param position New position of the sticker in the set, zero-based
func (client *Client) SetStickerPositionInSet(sticker InputFile, position int32) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setStickerPositionInSet",
        },
        Data: map[string]interface{}{
            "sticker": sticker,
            "position": position,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Removes a sticker from the set to which it belongs; for bots only. The sticker set must have been created by the bot
//
// @param sticker Sticker
func (client *Client) RemoveStickerFromSet(sticker InputFile) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "removeStickerFromSet",
        },
        Data: map[string]interface{}{
            "sticker": sticker,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Sends a custom request; for bots only
//
// @param method The method name
// @param parameters JSON-serialized method parameters
func (client *Client) SendCustomRequest(method string, parameters string) (*CustomRequestResult, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "sendCustomRequest",
        },
        Data: map[string]interface{}{
            "method": method,
            "parameters": parameters,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalCustomRequestResult(result.Data)
}

// Answers a custom query; for bots only
//
// @param customQueryId Identifier of a custom query
// @param data JSON-serialized answer to the query
func (client *Client) AnswerCustomQuery(customQueryId JsonInt64, data string) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "answerCustomQuery",
        },
        Data: map[string]interface{}{
            "custom_query_id": customQueryId,
            "data": data,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Succeeds after a specified amount of time has passed. Can be called before authorization
//
// @param seconds Number of seconds before the function returns
func (client *Client) SetAlarm(seconds float64) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setAlarm",
        },
        Data: map[string]interface{}{
            "seconds": seconds,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Uses current user IP to found his country. Returns two-letter ISO 3166-1 alpha-2 country code. Can be called before authorization
func (client *Client) GetCountryCode() (*Text, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getCountryCode",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalText(result.Data)
}

// Returns the default text for invitation messages to be used as a placeholder when the current user invites friends to Telegram
func (client *Client) GetInviteText() (*Text, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getInviteText",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalText(result.Data)
}

// Returns the terms of service. Can be called before authorization
func (client *Client) GetTermsOfService() (*Text, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getTermsOfService",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalText(result.Data)
}

// Sets the proxy server for network requests. Can be called before authorization
//
// @param proxy Proxy server to use. Specify null to remove the proxy server
func (client *Client) SetProxy(proxy Proxy) (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "setProxy",
        },
        Data: map[string]interface{}{
            "proxy": proxy,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns the proxy that is currently set up. Can be called before authorization
func (client *Client) GetProxy() (Proxy, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "getProxy",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    switch result.Type {
    case TypeProxyEmpty:
        return UnmarshalProxyEmpty(result.Data)

    case TypeProxySocks5:
        return UnmarshalProxySocks5(result.Data)

    default:
        return nil, errors.New("invalid type")
   }
}

// Does nothing; for testing only
func (client *Client) TestCallEmpty() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testCallEmpty",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Returns the received string; for testing only
//
// @param x String to return
func (client *Client) TestCallString(x string) (*TestString, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testCallString",
        },
        Data: map[string]interface{}{
            "x": x,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTestString(result.Data)
}

// Returns the received bytes; for testing only
//
// @param x Bytes to return
func (client *Client) TestCallBytes(x []byte) (*TestBytes, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testCallBytes",
        },
        Data: map[string]interface{}{
            "x": x,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTestBytes(result.Data)
}

// Returns the received vector of numbers; for testing only
//
// @param x Vector of numbers to return
func (client *Client) TestCallVectorInt(x []int32) (*TestVectorInt, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testCallVectorInt",
        },
        Data: map[string]interface{}{
            "x": x,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTestVectorInt(result.Data)
}

// Returns the received vector of objects containing a number; for testing only
//
// @param x Vector of objects to return
func (client *Client) TestCallVectorIntObject(x []*TestInt) (*TestVectorIntObject, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testCallVectorIntObject",
        },
        Data: map[string]interface{}{
            "x": x,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTestVectorIntObject(result.Data)
}

// For testing only request. Returns the received vector of strings; for testing only
//
// @param x Vector of strings to return
func (client *Client) TestCallVectorString(x []string) (*TestVectorString, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testCallVectorString",
        },
        Data: map[string]interface{}{
            "x": x,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTestVectorString(result.Data)
}

// Returns the received vector of objects containing a string; for testing only
//
// @param x Vector of objects to return
func (client *Client) TestCallVectorStringObject(x []*TestString) (*TestVectorStringObject, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testCallVectorStringObject",
        },
        Data: map[string]interface{}{
            "x": x,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTestVectorStringObject(result.Data)
}

// Returns the squared received number; for testing only
//
// @param x Number to square
func (client *Client) TestSquareInt(x int32) (*TestInt, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testSquareInt",
        },
        Data: map[string]interface{}{
            "x": x,
        },
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalTestInt(result.Data)
}

// Sends a simple network request to the Telegram servers; for testing only
func (client *Client) TestNetwork() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testNetwork",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Forces an updates.getDifference call to the Telegram servers; for testing only
func (client *Client) TestGetDifference() (*Ok, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testGetDifference",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalOk(result.Data)
}

// Does nothing and ensures that the Update object is used; for testing only
func (client *Client) TestUseUpdate() (Update, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testUseUpdate",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    switch result.Type {
    case TypeUpdateAuthorizationState:
        return UnmarshalUpdateAuthorizationState(result.Data)

    case TypeUpdateNewMessage:
        return UnmarshalUpdateNewMessage(result.Data)

    case TypeUpdateMessageSendAcknowledged:
        return UnmarshalUpdateMessageSendAcknowledged(result.Data)

    case TypeUpdateMessageSendSucceeded:
        return UnmarshalUpdateMessageSendSucceeded(result.Data)

    case TypeUpdateMessageSendFailed:
        return UnmarshalUpdateMessageSendFailed(result.Data)

    case TypeUpdateMessageContent:
        return UnmarshalUpdateMessageContent(result.Data)

    case TypeUpdateMessageEdited:
        return UnmarshalUpdateMessageEdited(result.Data)

    case TypeUpdateMessageViews:
        return UnmarshalUpdateMessageViews(result.Data)

    case TypeUpdateMessageContentOpened:
        return UnmarshalUpdateMessageContentOpened(result.Data)

    case TypeUpdateMessageMentionRead:
        return UnmarshalUpdateMessageMentionRead(result.Data)

    case TypeUpdateNewChat:
        return UnmarshalUpdateNewChat(result.Data)

    case TypeUpdateChatTitle:
        return UnmarshalUpdateChatTitle(result.Data)

    case TypeUpdateChatPhoto:
        return UnmarshalUpdateChatPhoto(result.Data)

    case TypeUpdateChatLastMessage:
        return UnmarshalUpdateChatLastMessage(result.Data)

    case TypeUpdateChatOrder:
        return UnmarshalUpdateChatOrder(result.Data)

    case TypeUpdateChatIsPinned:
        return UnmarshalUpdateChatIsPinned(result.Data)

    case TypeUpdateChatReadInbox:
        return UnmarshalUpdateChatReadInbox(result.Data)

    case TypeUpdateChatReadOutbox:
        return UnmarshalUpdateChatReadOutbox(result.Data)

    case TypeUpdateChatUnreadMentionCount:
        return UnmarshalUpdateChatUnreadMentionCount(result.Data)

    case TypeUpdateNotificationSettings:
        return UnmarshalUpdateNotificationSettings(result.Data)

    case TypeUpdateChatReplyMarkup:
        return UnmarshalUpdateChatReplyMarkup(result.Data)

    case TypeUpdateChatDraftMessage:
        return UnmarshalUpdateChatDraftMessage(result.Data)

    case TypeUpdateDeleteMessages:
        return UnmarshalUpdateDeleteMessages(result.Data)

    case TypeUpdateUserChatAction:
        return UnmarshalUpdateUserChatAction(result.Data)

    case TypeUpdateUserStatus:
        return UnmarshalUpdateUserStatus(result.Data)

    case TypeUpdateUser:
        return UnmarshalUpdateUser(result.Data)

    case TypeUpdateBasicGroup:
        return UnmarshalUpdateBasicGroup(result.Data)

    case TypeUpdateSupergroup:
        return UnmarshalUpdateSupergroup(result.Data)

    case TypeUpdateSecretChat:
        return UnmarshalUpdateSecretChat(result.Data)

    case TypeUpdateUserFullInfo:
        return UnmarshalUpdateUserFullInfo(result.Data)

    case TypeUpdateBasicGroupFullInfo:
        return UnmarshalUpdateBasicGroupFullInfo(result.Data)

    case TypeUpdateSupergroupFullInfo:
        return UnmarshalUpdateSupergroupFullInfo(result.Data)

    case TypeUpdateServiceNotification:
        return UnmarshalUpdateServiceNotification(result.Data)

    case TypeUpdateFile:
        return UnmarshalUpdateFile(result.Data)

    case TypeUpdateFileGenerationStart:
        return UnmarshalUpdateFileGenerationStart(result.Data)

    case TypeUpdateFileGenerationStop:
        return UnmarshalUpdateFileGenerationStop(result.Data)

    case TypeUpdateCall:
        return UnmarshalUpdateCall(result.Data)

    case TypeUpdateUserPrivacySettingRules:
        return UnmarshalUpdateUserPrivacySettingRules(result.Data)

    case TypeUpdateUnreadMessageCount:
        return UnmarshalUpdateUnreadMessageCount(result.Data)

    case TypeUpdateOption:
        return UnmarshalUpdateOption(result.Data)

    case TypeUpdateInstalledStickerSets:
        return UnmarshalUpdateInstalledStickerSets(result.Data)

    case TypeUpdateTrendingStickerSets:
        return UnmarshalUpdateTrendingStickerSets(result.Data)

    case TypeUpdateRecentStickers:
        return UnmarshalUpdateRecentStickers(result.Data)

    case TypeUpdateFavoriteStickers:
        return UnmarshalUpdateFavoriteStickers(result.Data)

    case TypeUpdateSavedAnimations:
        return UnmarshalUpdateSavedAnimations(result.Data)

    case TypeUpdateConnectionState:
        return UnmarshalUpdateConnectionState(result.Data)

    case TypeUpdateNewInlineQuery:
        return UnmarshalUpdateNewInlineQuery(result.Data)

    case TypeUpdateNewChosenInlineResult:
        return UnmarshalUpdateNewChosenInlineResult(result.Data)

    case TypeUpdateNewCallbackQuery:
        return UnmarshalUpdateNewCallbackQuery(result.Data)

    case TypeUpdateNewInlineCallbackQuery:
        return UnmarshalUpdateNewInlineCallbackQuery(result.Data)

    case TypeUpdateNewShippingQuery:
        return UnmarshalUpdateNewShippingQuery(result.Data)

    case TypeUpdateNewPreCheckoutQuery:
        return UnmarshalUpdateNewPreCheckoutQuery(result.Data)

    case TypeUpdateNewCustomEvent:
        return UnmarshalUpdateNewCustomEvent(result.Data)

    case TypeUpdateNewCustomQuery:
        return UnmarshalUpdateNewCustomQuery(result.Data)

    default:
        return nil, errors.New("invalid type")
   }
}

// Does nothing and ensures that the Error object is used; for testing only
func (client *Client) TestUseError() (*Error, error) {
    result, err := client.Send(Request{
        meta: meta{
            Type: "testUseError",
        },
        Data: map[string]interface{}{},
    })
    if err != nil {
        return nil, err
    }

    if result.Type == "error" {
        return nil, buildResponseError(result.Data)
    }

    return UnmarshalError(result.Data)
}
